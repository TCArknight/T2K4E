<?xml version="1.0" encoding="UTF-8"?>

<!-- This file contains the definitions of components associated with equipment such as
      weapons, armor, gear, etc.
-->

<document signature="Hero Lab Structure">

  <!-- Gear component
        All gear must derive from this component
        NOTE! Designate this component as "gear" to enable containment handling.
  -->
  <component
    id="Gear"
    name="Gear"
    isgear="yes"
    autocompset="no"
    ispublic="no"
    addbehavior="never">
	  
    <!-- Stack name field - name is prefixed with the quantity if not a value of one,
          which is important for stackable items that can have varying quantities
    -->
    <field
      id="grStkName"
      name="(Qty) Name"
      type="derived"
      maxfinal="100"
      nevercache="yes">
      <!-- Final value for display consists of the name with a prefixed quantity
            if not one
      -->
      <finalize><![CDATA[
        ~if we have a customized name already, use it; otherwise, use the default name
        var name as string
        if (field[livename].isempty = 0) then
          name = field[livename].text
        else
          name = field[name].text
          endif

        ~if we're not stackable or if our quantity is one, just use the simple name
        if (stackable = 0) then
          @text = name
        elseif (field[stackQty].value = 1) then
          @text = name

        ~prefix the name with the quantity
        else
          @text = "(" & field[stackQty].value & "x) " & name
          endif
        ]]></finalize>
      </field>

    <!-- Gear cost -->
    <field
      id="grCost"
      name="Cost"
      minvalue="0"
      defvalue="0"
      type="derived"
      maxfinal="10">
      <!-- If a "lot cost" is specified, calculate the individual cost from it -->
      <calculate phase="Initialize" priority="5000"><![CDATA[
        ~if we have a 'lot cost', find the cost for a single item by dividing
        ~it by the lot size.
        ~NOTE: The calculate script is only applied to picks - not things - so
        ~     we must also do this calculation in both the Finalize script and
        ~     the TransactionSetup script, so they behave properly on things.
        if (field[grLotCost].value > 0) then
          @value = field[grLotCost].value / field[lotsize].value
          endif
        ]]></calculate>
      <!-- Final value for display has the dollar sign prepended -->
      <finalize><![CDATA[
        ~if this is a thing, we have to determine the value for use below; if we
        ~have a non-zero lot cost, override our value based on the lot cost, else
        ~use multiply the unit code by the lot size. See the Calculate script
        ~comments for more details.
        if (ispick = 0) then
          if (field[grLotCost].value > 0) then
            @value = field[grLotCost].value
          else
            @value = field[grCost].value * field[lotsize].value
            endif
          endif

        ~convert the cost to a value for display appropriately
        if (@value = 0) then
          @text = chr(150)
        else
          var moneyvalue as number
          var money as string
          moneyvalue = @value
          call Money
          @text = money
          endif
        ]]></finalize>
      </field>

    <!-- Gear lot cost - used when you have a set of items that are priced in
          the rulebook as $X for Y items. For example, if 30 bullets cost $10,
          we want 3 bullets to cost $1, but setting grCost to $.33 would yield
          a cost of $0.99. So we specify the lot cost and everything works.
    -->
    <field
      id="grLotCost"
      name="Lot Cost"
      minvalue="0"
      defvalue="0"
      type="static">
      </field>

    <field
      id="grTotalCost"
      name="Total Cost"
      minvalue="0"
      defvalue="0"
      type="derived">
      </field>

    <field
      id="grReliability"
      name="Reliability"
      minvalue="0"
      maxvalue="6"
      type="derived">
      </field>

    <field
      id="grWeight"
      name="Weight"
      minvalue="0"
      decimals="2"
      type="derived">
      </field>
	  
    <!-- Supply rating of a piece of gear is determined by the SupplyRating.XXX tag -->
	
    <!-- Initialize the gear characteristics from our transaction pick (if any) -->
    <creation><![CDATA[
      ~if we don't have a transaction pick to initialize from, bail out; this can
      ~occur if the gear is bootstrapped or auto-added for the actor
      doneif (hero.istransact = 0)

      ~initialize our fields appropriately from the transaction pick
      ~.... add any necessary code here ....
      ]]></creation>

    <!-- Call the appropriate procedures to perform transaction setup, buy, and sell behaviors -->
    <xactsetup><![CDATA[
	  	
	  ~ammo reload costs depend on the cost of the weapon
	  ~notify "Component: " & tagnames[component.?,"|"]
	
      ~perform standard transaction setup for the gear
      call XactSetup

      ~initialize any transaction fields appropriately from this piece of gear
      ~.... add code here ....
      ]]></xactsetup>

    <xactbuy><![CDATA[
      call XactBuy
      ]]></xactbuy>

    <xactsell><![CDATA[
      call XactSell
      ]]></xactsell>
	  
    <!-- Accrue the weight of this item into the character, as appropriate -->
    <eval index="1" phase="Effects" priority="10000" name="Accrue Weight"><![CDATA[
      ~if this piece of gear is held by something else, ignore it - we'll get it below
      doneif (isgearheld <> 0)

      ~if this piece of gear is a topmost holder, ignore it - it's not on the character
      doneif (tagis[thing.holder_top] <> 0)

      ~if this piece of gear is of negligable weight, then it doesn't count against encumbrance
      doneif (tagis[Equipment.TinyItem] <> 0)
	  
      ~accrue the net weight of this piece of gear into the character
      herofield[acCarryCombat].value += field[gearNet].value
      ]]></eval>


    <!-- Accrue the total value of this item, as appropriate -->
    <eval index="2" phase="Final" priority="10000" name="Accrue Total Cost"><![CDATA[
      ~accrue the net weight of this piece of gear into the character
      if (stackable = 1) then
        field[grTotalCost].value += field[grCost].value * field[stackQty].value
      else
        field[grTotalCost].value += field[grCost].value
      endif
      ]]></eval>
	  
    <!-- Accrue the total value of this item, as appropriate -->
    <eval index="2" phase="Initialize" priority="10000" name="Set gearWeight"><![CDATA[
      field[gearWeight].value += field[grWeight].value
  
      ]]></eval>

    </component>


  <!-- Equipment component
        All general non-combat equipment derives from this component
  -->
  <component
    id="Equipment"
    name="Equipment"
    autocompset="no"
    panellink="gear">

    </component>

  <!-- Consumable component
        All equipment with consumables have this component
  -->
  <component
    id="Consumable"
    name="Consumables"
    autocompset="no"
    panellink="gear">

    <field
      id="grAir"
      name="Air Supply Consumable"
      type="derived">
      </field>
	
    <field
      id="grPower"
      name="Power Supply Consumable"
      type="derived">
      </field>
	
    <field
      id="grWater"
      name="Water Supply Consumable"
      type="derived">
      </field>
	  
    <field
      id="grFood"
      name="Food Supply Consumable"
      type="derived">
      </field>

    <!-- Synthesized notes about the consumables -->
    <field
      id="grConsumables"
      name="Consumables"
      type="derived"
      maxlength="250">
      </field>	  
    <!-- Assign any derived special notes to the appropriate field -->
    <eval index="1" phase="Render" priority="1000" name="Consumables Summary"><![CDATA[
      var summary as string

      ~report the Air value
      if ((tagis[Consumables.Air] + field[grAir].value ) <> 0) then
        summary = splice(summary,"Air: " & field[grAir].value,", ")
		if (field[grIsEquip].value <> 0) then
		  herofield[acConsumeAir].value += field[grAir].value
		  endif
        endif

      ~report the Food value
      if ((tagis[Consumables.Food] + field[grFood].value ) <> 0) then
        summary = splice(summary,"Food: " & field[grFood].value,", ")
		if (field[grIsEquip].value <> 0) then
		  herofield[acConsumeFood].value += field[grFood].value
		  endif
        endif

      ~report the Power value
      if ((tagis[Consumables.Power] + field[grPower].value ) <> 0) then
        summary = splice(summary,"Power: " & field[grPower].value,", ")
		if (field[grIsEquip].value <> 0) then
		  herofield[acConsumePower].value += field[grPower].value
		  endif
        endif


      ~report the Water value
      if ((tagis[Consumables.Water] + field[grWater].value ) <> 0) then
        summary = splice(summary,"Water: " & field[grWater].value,", ")
		if (field[grIsEquip].value <> 0) then
		  herofield[acConsumeWater].value += field[grWater].value
		  endif
        endif
		
      ~we've synthesized the consumables entry
      field[grConsumables].text = summary
	  
      ]]></eval>
    </component>

  <!-- Vehicle component
        All vehicles use this to display for purchase/selection
  -->
  <component
    id="Vehicle"
    name="Vehicle Helper"
    autocompset="no">

    </component>
	
  <!-- VehicleBase component
        All vehicles use this for the vehicle details/attributes
  -->  
  <component
    id="VehicleBase"
    name="Vehicle Base"
	autocompset="no">	

    <field
      id="vebReliability"
      name="Reliability"
      minvalue="0"
      maxvalue="6"
      type="derived">
      </field>
	  
    <field
      id="vebCombatSpeedOn"
      name="Combat Speed (On Road)"
      minvalue="0"
      defvalue="0"
      type="derived">
	  </field>
	
    <field
      id="vebTravelSpeedOff"
      name="Travel Speed (Off Road)"
      minvalue="0"
      defvalue="0"
      type="derived">
	  </field>
	
    <field
      id="vebTravelSpeedOn"
      name="Travel Speed (On Road)"
      minvalue="0"
      defvalue="0"
      type="derived">
	  </field>
	
    <field
      id="vebCombatSpeedOff"
      name="Combat Speed (Off Road)"
      minvalue="0"
      defvalue="0"
      type="derived">
	  </field>  
    <eval index="1" phase="Initialize" priority="4500"><![CDATA[
	  trustme
      ~initialize Attributes
	  #setvehicle[attrVehRel] = field[vebReliability].value
	  #setvehicle[attrVehCbtSpdOn] = field[vebCombatSpeedOn].value
	  #setvehicle[attrVehCbtSpdOff] = field[vebCombatSpeedOff].value
	  #setvehicle[attrVehTraSpdOn] = field[vebTravelSpeedOn].value
	  #setvehicle[attrVehTraSpdOff] = field[vebTravelSpeedOff].value
	  
	  
	  perform hero.findchild[VehicleDetails].setfocus
	  doneif (state.isfocus = 0)
	  
	  focus.field[vdeCategory].text = tagnames[VehicleCat.?,"/"]
	  focus.field[vdeType].text = tagnames[VehicleType.?,"/"]
	  focus.field[vdeReliability].value = field[vebReliability].value
	  focus.field[vdeCombatSpeedOn].value = field[vebCombatSpeedOn].value
	  focus.field[vdeCombatSpeedOff].value = field[vebCombatSpeedOff].value
	  focus.field[vdeTravelSpeedOn].value = field[vebTravelSpeedOn].value
	  focus.field[vdeTravelSpeedOff].value = field[vebTravelSpeedOff].value
	  
      ]]></eval>
	  
    </component>
	
  <component
    id="VehicleDetails"
    name="Vehicle Details"
    ispublic="no">
	
	<field
      id="vdeCategory"
      name="Vehicle Category"
      type="derived"
	  maxlength="25">
      </field>
	  
    <field
      id="vdeType"
      name="Vehicle Type"
      type="derived"
	  maxlength="25">
	  </field>
		
	<field
      id="vdeReliability"
      name="Reliability"
      type="derived">
      </field>
	  
    <field
      id="vdeCombatSpeedOn"
      name="Combat Speed (On Road)"
      type="derived">
	  </field>
	
    <field
      id="vdeCombatSpeedOff"
      name="Combat Speed (Off Road)"
      type="derived">
	  </field>
	
    <field
      id="vdeTravelSpeedOn"
      name="Travel Speed (On Road)"
      type="derived">
	  </field>
	  
    <field
      id="vdeTravelSpeedOff"
      name="Travel Speed (Off Road)"
      type="derived">
	  </field>	
	  
    </component>
	
  <component
    id="VehicleAlt"
    name="Vehicle"
    panellink="gear"
    autocompset="no">

    <!-- Acceleration -->
    <field
      id="vhAccel"
      name="Acceleration"
      type="derived"
      maxlength="10">
      </field>

    <!-- Top Speed -->
    <field
      id="vhTopSpeed"
      name="Top Speed"
      type="derived"
      maxlength="15">
      </field>

    <!-- Handling -->
    <field
      id="vhHandling"
      name="Handling"
      type="derived"
      maxlength="10">
      </field>

    <!-- Climb (applies to aircraft only) -->
    <field
      id="vhClimb"
      name="Climb"
      type="derived"
      maxlength="15">
      </field>

    <!-- Toughness -->
    <field
      id="vhTough"
      name="Toughness"
      type="derived"
      maxlength="10">
      </field>

    <!-- Armor -->
    <field
      id="vhArmor"
      name="Armor"
      type="derived"
      maxlength="10">
      </field>

    <!-- Crew -->
    <field
      id="vhCrew"
      name="Crew"
      type="derived"
      maxlength="10">
      </field>

    <!-- Crew -->
    <field
      id="vhCrewOg"
      name="Original Crew Value"
      type="derived"
      maxlength="10">
      </field>

    <!-- Cost Range -->
    <field
      id="vhCost"
      name="Cost Range"
      type="static"
      maxlength="20">
      </field>

    <!-- Special details about the vehicle -->
    <field
      id="vhSpecial"
      name="Special"
      type="derived"
      maxlength="200">
      </field>

    <!-- Synthesized notes about the vehicle -->
    <field
      id="vhNotes"
      name="Notes"
      type="derived"
      maxlength="250">
      </field>

    <!-- Load-out details for the vehicle that are only displayed for things -->
    <field
      id="vhLoadout"
      name="Load-Out"
      type="derived"
      maxlength="250">
      </field>

    <!-- RDS SFC Vehicle Size - this is used in the cost and size calculations for some Modifications -->
    <field
      id="vhSize"
      name="Size"
      type="static">
      </field>

    <!-- RDS SFC Energy for Starships -->
    <field
      id="vhEnergy"
      name="Energy"
      type="derived">
      </field>

    <!-- RDS SFC Energy for Starships - this contains the original value for calculations -->
    <field
      id="vhEnergyOg"
      name="Energy, original value"
      type="derived">
      </field>

    <!-- RDS SFC Firewall is for Interface Zero 2.0 -->
    <field
      id="vhFirewall"
      name="Firewall"
      type="derived">
      </field>

    <!-- RDS Heat Radiation is for Seven Worlds -->
    <field
      id="vhHeatRadiation"
      name="Heat Radiation"
      type="derived">
      </field>

    <!-- RDS Shield Effects is for Seven Worlds -->
    <field
      id="vhShieldEffects"
      name="Shield Effects"
      type="derived">
      </field>

    <!-- RDS Jumps is for Seven Worlds -->
    <field
      id="vhJumps"
      name="Jumps"
      type="derived">
      </field>

    <!-- RDS Weeks per Jump is for Seven Worlds -->
    <field
      id="vhWeeksJump"
      name="Weeks per Jump"
      type="derived">
      </field>

    <!-- Setup a condition test to force our live state to resolve before the live
          state of any picks added to the child gizmo are resolved. This is needed
          to avoid run-time errors that will be reported if the picks on the child
          gizmo try to resolve their live state before the live state of the gizmo
          itself is resolved.
    -->
    <containerreq phase="Initialize" priority="900">TRUE</containerreq>

    <!-- RDS Set up a condition test to force our live state to resolve before the live
          state of any picks added to the child gizmo are resolved. This is needed
          to avoid run-time errors that will be reported if the picks on the child
          gizmo try to resolve their live state before the live state of the gizmo
          itself is resolved.
    -->
    <eval index="1" phase="Initialize" priority="2000"><![CDATA[
      ~Vehicles are by defintion holders, most have it applied manually
      if (tagis[thing.holder_top] = 0) then
        perform assign[thing.holder_top]
        endif
      field[vhCrewOg].text = field[vhCrew].text
      ]]></eval>

    <!-- Assign any derived special notes to the appropriate field 
    <eval index="2" phase="Render" priority="1000"><![CDATA[
      var special as string

      ~append any special attributes appropriately (if any)
      var attribs as string
      attribs = tagnames[Vehicle.?,", "]
      if (empty(attribs) = 0) then
        if (empty(special) = 0) then
          special &= ", "
          endif
        special &= attribs
        endif

      ~append any special details for this vehicle
      if (field[vhSpecial].isempty = 0) then
        if (empty(special) = 0) then
          special &= ", "
          endif
        special &= field[vhSpecial].text
        endif

      ~we've synthesized the notes for the vehicle
      field[vhNotes].text = special
      ]]></eval> 

    <eval index="3" phase="Setup" priority="7000" name="Alter Mods Used by Fixed/Linked"><![CDATA[
      var fixed     as number
      var linked    as number
      var fixlinked as number
      var totalmod  as number
      
      ~ RDS SFC While we'e here, set the vhEnergyOg field to the original vhEnergy value
      field[vhEnergyOg].value = field[vhEnergy].value
      
      ~ RDS SFC This routine alters the space taken up when weapons are either Fixed, Linked or both.
      if (isgizmo = 1) then
        ~Remove gearWeight for weapons on vehicles so they do not affect character encumbrance
        foreach pick in gizmo where "component.WeaponBase"
          eachpick.field[gearWeight].value = 0
          nexteach

        foreach pick in gizmo where "component.WeapSpec | User.WepMount"
          eachpick.field[gearWeight].value = 0
          if (eachpick.field[wsLinked].value + eachpick.field[wsFixed].value = 2) then
            if (eachpick.field[stackQty].value > 1) then 
              var modsused as number
              modsused = eachpick.field[grModsUsed].text
              fixlinked += modsused * eachpick.field[stackQty].value
            else
              fixlinked += eachpick.field[grModsUsed].text
              endif
          else
            if (eachpick.field[wsFixed].value = 1) then
              if (eachpick.field[stackQty].value > 1) then 
                var modsused as number
                modsused = eachpick.field[grModsUsed].text
                fixed += modsused * eachpick.field[stackQty].value
              else
                fixed += eachpick.field[grModsUsed].text
                endif
              endif
            if (eachpick.field[wsLinked].value = 1) then
              if (eachpick.field[stackQty].value > 1) then 
                var modsused as number
                modsused = eachpick.field[grModsUsed].text
                linked += modsused * eachpick.field[stackQty].value
              else
                linked += eachpick.field[grModsUsed].text
                endif
              endif
            endif
          nexteach

        if (fixlinked > 0) then
          fixlinked = fixlinked - (fixlinked/4)
          fixlinked = round(fixlinked,0,-1)
          endif

        if (fixed > 0) then
          fixed = fixed/2
          fixed = round(fixed,0,-1)
          endif
      
        if (linked > 0) then
          linked = linked/2
          linked = round(linked,0,-1)
          endif
      
        totalmod = fixlinked + fixed + linked
        field[grCurrMods].value -= totalmod
        endif
      ]]></eval> -->
    <evalrule index="1" phase="Validate" priority="9000" message="Crew can't go below zero."><![CDATA[
        var crew as number
        crew = field[vhCrew].text
        validif (crew >= 0)
      ]]></evalrule>

    </component>
	
  <!-- Equippable component
        Any gear that can be equipped (e.g. weapons) must derive from this component.
        A field is managed that tracks whether the gear is actually equipped, and the
        state can be controlled via a checkbox presented to the user. Equipped gear
        automatically accrues the number of hands required to ensure that a character
        doesn't equip more gear than he has hands for.
  -->
  <component
    id="Equippable"
    name="Equippable"
    autocompset="no"
    ispublic="no">

    <!-- Is the gear equipped? -->
    <field
      id="grIsEquip"
      name="Is Equipped?"
      type="user"
      minvalue="0"
      maxvalue="1">
      </field>

    <!-- If the equipment should be selected by default, select it now -->
    <creation><![CDATA[
      ~if this is natural equipment, initialize the equipped state
      if (tagis[Equipment.Natural] <> 0) then
        field[grIsEquip].value = tagis[Equipment.AutoEquip]
        endif

      ~if this equipment is supposed to start out as equipped, initialize the state
      if (tagis[Equipment.StartEquip] <> 0) then
        field[grIsEquip].value = 1
        endif
      ]]></creation>

    <!-- If we're equipped, assign ourselves the corresponding tag -->
    <eval index="1" phase="Initialize" priority="5000" name="Equipped"><![CDATA[
      if (field[grIsEquip].value <> 0) then
        perform assign[Equipped.Equipped]
        endif
      ]]></eval>

    <!-- If this equipment is a automatically equipped (e.g. a natural attack), we
          can't be moved and we must force the equipped state
    -->
    <eval index="2" phase="Initialize" priority="4000">
      <before name="Equipped"/><![CDATA[
      if (tagis[Equipment.AutoEquip] <> 0) then
        perform assign[Helper.NoMove]
        ~since the equipped field is a "user" field, we need to tell the compiler
        ~not to complain before setting the field
        trustme
        field[grIsEquip].value = 1
        endif
      ]]></eval>

    <!-- If equipped, tell the actor how many hands worth of equipment is equipped -->
    <eval index="3" phase="Final" priority="5000">
      <before name="Check Hands"/><![CDATA[
      ~if not equipped, there's nothing to do
      doneif (field[grIsEquip].value = 0)

      ~if the equipment does not require hands, there's nothing to do
      doneif (tagis[Equipment.Hand] = 0)

      ~tell the hero we've got at least one hand used
      perform hero.assign[Hero.Hand]

      ~if the equipment is two-handed, add another hand
      if (tagis[Equipment.TwoHand] <> 0) then
        perform hero.assign[Hero.Hand]
        endif
      ]]></eval>

    <!-- If equipped and we're out of hands, mark ourselves as invalid but don't
        trigger a separate validation error for each weapon -->
    <evalrule index="1" phase="Validate" priority="10000" message="?" issilent="yes"><![CDATA[
      ~if the hero isn't over the hands limit, we're valid
      validif (hero.tagcount[Hero.Hand] <= herofield[acHands].value)

      ~if not equipped, we're valid
      validif (field[grIsEquip].value = 0)

      ~if the equipment does not require any hands, we're valid
      validif (tagis[Equipment.Hand] = 0)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    <!-- If equipped and held within a container, we have a conflict -->
    <evalrule index="2" phase="Validate" priority="10000" message="Gear is equipped while stored in a container"><![CDATA[
      ~if not both equipped and held within a container, we're valid
      validif (field[grIsEquip].value + isgearheld < 2)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    </component>


  <!-- WeaponBase component
        All weapons derive from this component. Weapons track a bonus value and damage
        rating, as well as a strength requirement. The net attack value for the weapon
        is calculating, incorporating any penalties that may be applied due to special
        circumstances (e.g. failing to meet the strength requirement).
  -->
  <component
    id="WeaponBase"
    name="Weapon"
    autocompset="no"
    hasshortname="yes"
    panellink="armory"
    ispublic="no">

    <!-- Weapon bonus -->
    <field
      id="wpBonus"
      name="Weapon Bonus"
      type="derived">
      </field>

    <!-- Damage rating of the weapon -->
    <field
      id="wpDamage"
      name="Damage"
      type="derived"
      maxlength="20">
      </field>
	  
    <!-- Weapon Crit rating -->
    <field
      id="wpCrit"
      name="Weapon Crit Rating"
      type="derived"
      maxlength="20">
      </field>

    <!-- armor rating for the weapon -->
    <field
      id="wpArmorRating"
      name="Armor Rating"
      type="derived"
      maxlength="20">
      </field>
	  
    <!-- Minimum strength required to wield -->
    <field
      id="wpStrReq"
      name="Minimum Strength"
      type="static">
      </field>

    <!-- Special details about the weapon -->
    <field
      id="wpSpecial"
      name="Special"
      type="derived"
      maxlength="200">
      </field>

    <!-- Synthesized notes about the weapon -->
    <field
      id="wpNotes"
      name="Notes"
      type="derived"
      maxlength="250">
      </field>

    <!-- Weapon penalty -->
    <field
      id="wpPenalty"
      name="Weapon Penalty"
      type="derived">
      </field>

    <!-- Net attack roll for weapon -->
    <field
      id="wpNetAtk"
      name="Net Attack"
      type="derived"
      maxlength="20">
      </field>
	  
    <!-- Weapons require one hand by default (unless natural) -->
    <tag group="Equipment" tag="Hand"/>

    <!-- If equipped and the minimum strength isn't satisfied, apply any penalty and
        mark ourselves as not satisfying the requirement -->
    <eval index="1" phase="Final" priority="5000"><![CDATA[
      ~if the minimum strength is satisfied, there's nothing to do
      doneif (field[wpStrReq].value <= #trait[attrStr])

      ~assign a tag to indicate the requirement isn't met
      perform assign[Helper.BadStrReq]

      ~apply any penalty required with the specific weapon
      field[wpPenalty].value = -1

      ~if not equipped, there's nothing more to do
      doneif (field[grIsEquip].value = 0)

      ~apply any general penalty required (e.g. defense penalties or the like)
      ~.... add code here ....
      ]]></eval>
    <eval index="2" phase="Final" priority="1000"><![CDATA[
      if (tagis[Helper.DamageByAmmo] <> 0) then
	    field[wpDamage].text = "By Ammo"
		endif
      ]]></eval>	
	  
    <!-- Assign any derived special notes to the appropriate field -->
    <eval index="3" phase="Render" priority="1000"><![CDATA[
      var special as string

      ~report the weapon as two-handed (if any)
      if (tagis[Equipment.TwoHand] <> 0) then
        special = splice(special,"Requires two hands",", ")
        endif

      ~append any special attributes appropriately (if any)
      var attribs as string
      attribs = tagnames[WeaponSpec.?,", "]
      special = splice(special,attribs,", ")

      ~append any special details for this weapon
      special = splice(special,field[wpSpecial].text,", ")

      ~we've synthesized the notes for the weapon
      field[wpNotes].text = special
      ]]></eval>

    <!-- Check the strength requirement, which we only treat as a problem for things. -->
    <prereq message="Strength requirement not met.">
      <validate><![CDATA[
        ~if this is a pick, we're valid
        ~NOTE! We assume that equipping an item without the strength just applies penalties.
        validif (@ispick <> 0)

        ~verify whether we meet the strength requirement
        validif (#trait[attrStr] >= altthing.field[wpStrReq].value)
        ]]></validate>
      </prereq>

    </component>


  <!-- WeapRange component
        Ranged weapons derive from this component. They add range distances for three
        different range classifications. For simplicity, a text-based version of the
        ranges is automatically generated for easy use in displaying the weapon.
        Ranged weapons auto-calculate their net attack value based on the Shooting
        skill.
  -->
  <component
    id="WeapRange"
    name="Ranged Weapon"
    autocompset="no">

    <!-- ammo capacity for the weapon -->
    <field
      id="wpCapacity"
      name="Ammo Capacity"
      type="derived">
      </field>
	  
    <!-- maximum rate of fire for the weapon -->
    <field
      id="wpRateOfFire"
      name="Rate Of Fire"
      type="derived">
      </field>	
	  
    <!-- Short range for the weapon -->
    <field
      id="wpShort"
      name="Short Range"
      type="derived">
      </field>

    <!-- Medium range for the weapon -->
    <field
      id="wpMedium"
      name="Medium Range"
      type="derived">
      </field>

    <!-- Long range for the weapon -->
    <field
      id="wpLong"
      name="Long Range"
      type="derived">
      </field>

	  
    <!-- Synthesized text ranges for the weapon -->
    <field
      id="wpRange"
      name="Range"
      type="derived"
      maxfinal="25"> 
	  
      <!-- Calculate the value based on all three range elements so that any changes
          to any value safely trigger an update of the finalized value -->
      
      <calculate phase="Render" priority="10000"><![CDATA[
        @value = field[wpShort].value * 100000000 + field[wpMedium].value * 10000 + field[wpLong].value
        ]]></calculate>
		
      <!-- Final value for display is a blending of the various range values -->
      <finalize><![CDATA[
        if (tagis[WeaponSpec.SpecRange] <> 0) then
          @text = "Special"
        else
		  if (tagcount[MaxRange.?] <> 0) then
		    @text = tagnames[MaxRange.?,"/"]
		  else
            @text = field[wpShort].value
			~ field[wpShort].value & "/" & field[wpMedium].value & "/" & field[wpLong].value
			endif
          endif
        ]]></finalize>
      </field>
	  
    <!-- Reload cost multiplier -->
    <field
      id="wpReloadCost"
      name="Cost"
      minvalue="0"
      defvalue="0.05"
      type="derived">
      </field>
	  
    <!-- Reload cost multiplier -->
    <field
      id="wpBlast"
      name="Blast Rating"
      type="derived"
	  maxlength="15"
	  maxfinal="15">
	  <finalize><![CDATA[
        @text = tagnames[BlastRating.?,","]
        ]]></finalize>
      </field>
	  
    <!-- All ranged weapons get the same tag for sorting purposes -->
    <tag group="Armory" tag="Range"/>

    <!-- Calculate the net attack roll for the weapon -->
    <eval index="1" phase="Final" priority="7000" name="Calc wpNetAtk"><![CDATA[
	  var AttPlusSki as string
	  var WpnSkill as string
	  
	  if (tagis[WeaponType.Thrown] <> 0) then
	    WpnSkill = "SkillUse.Thrown"
	  else
	    WpnSkill = "SkillUse.Ranged"
		endif
		
      WpnSkill &= " & (fieldval:trtFinal > 2)"
	  
	  AttPlusSki = #traitalpha[attrAgi]  

	  ~find the skill tagged as the Ranged Combat skill
      foreach pick in hero from Skill where WpnSkill
        AttPlusSki &= "+" & eachpick.field[trtAlpha].text
        nexteach
		
      ~ field[wpNetAtk].value += field[wpBonus].value + field[wpPenalty].value
	  field[wpNetAtk].text = AttPlusSki
	  
      ]]></eval>

    <!-- Prepend any derived special notes to the appropriate field -->
    <eval index="2" phase="Render" priority="2000"><![CDATA[
      var special as string

      ~assign any appropriate special notes to the "special" variable here
      if (tagis[BlastRating.?] <> 0) then
	    special = "Blast: " & field[wpBlast].text
		endif
		
      ~prepend any existing special details with the notes for this weapon
      field[wpNotes].text = splice(special,field[wpNotes].text,", ")
      ]]></eval>
	  
    <!-- Ammo Type script, generate the tagexpr relevant for our modification gizmo -->
    <eval index="2" phase="Render" priority="5000" name="AmmoType Tag Expression generate"><![CDATA[
	  var myId as string
	  var myCost as number
	  var reloadCost as number
	  
      myId = tagids[AmmoType.?," & "]
	  myCost = field[grCost].value
	  reloadCost = field[wpReloadCost].value
  
      call SetAmmoExpr
      ]]></eval>
    </component>


  <!-- WeapMelee component
        Melee weapons derive from this component. Melee weapons auto-calculate their
        net attack value based on the Melee skill.
  -->
  <component
    id="WeapMelee"
    name="Melee Weapon"
    autocompset="no">
	  
    <!-- All melee weapons get the same tag for sorting purposes -->
    <tag group="Armory" tag="Melee"/>
	
    <!-- By default, melee weapons are Engaged Range-->
    <tag group="MaxRange" tag="Engaged"/>

    <!-- All melee weapons get the appropriate tag -->
    <eval index="1" phase="Setup" priority="5000"><![CDATA[
      perform assign[Armory.Melee]
      ]]></eval>

    <!-- Calculate the net attack roll for the weapon -->
    <eval index="2" phase="Final" priority="7000" name="Calc wpNetAtk"><![CDATA[
	  var AttPlusSki as string
	  
	  AttPlusSki = #traitalpha[attrStr]
	  
	  ~find the skill tagged as the Melee Combat skill
      foreach pick in hero from Skill where "SkillUse.Melee & (fieldval:trtFinal > 2)"
        AttPlusSki &= "+" & eachpick.field[trtAlpha].text
        nexteach
		
      ~ field[wpNetAtk].value += field[wpBonus].value + field[wpPenalty].value
	  field[wpNetAtk].text = AttPlusSki
      ]]></eval>

    <!-- Prepend any derived special notes to the appropriate field -->
    <eval index="3" phase="Render" priority="2000"><![CDATA[
      var special as string

      ~assign any appropriate special notes to the "special" variable here

      ~prepend any existing special details with the notes for this weapon
      field[wpNotes].text = splice(special,field[wpNotes].text,", ")
      ]]></eval>

    </component>


  <!-- Defense component
        All armor and shields derive from this component. Defensive gear tracks a
        defense rating and a strength requirement. The defense rating is added to the
        character's overall Defense trait when the gear is equipped.
  -->
  <component
    id="Defense"
    name="Defense"
    autocompset="no"
	hasshortname="yes"
    panellink="armory"
    ispublic="no">

    <!-- Defense adjustment conferred by the equipment -->
    <field
      id="defDefense"
      name="Defense Adjustment"
      type="derived">
      </field>
	  
    <!-- Minimum strength required to use the equipment -->
    <field
      id="defStrReq"
      name="Minimum Strength"
      type="static">
      </field>

    <!-- Special details about the weapon -->
    <field
      id="defSpecial"
      name="Special"
      type="derived"
      maxlength="200">
      </field>

    <!-- Synthesized notes about the weapon -->
    <field
      id="defNotes"
      name="Notes"
      type="derived"
      maxlength="250">
      </field>
	  
    <!-- If equipped and the minimum strength isn't satisfied, apply any penalty and
        mark ourselves as not satisfying the requirement -->
    <eval index="1" phase="Final" priority="5000"><![CDATA[
      ~if the minimum strength is satisfied, there's nothing to do
      doneif (field[defStrReq].value <= #trait[attrStr])

      ~assign a tag to indicate the requirement isn't met
      perform assign[Helper.BadStrReq]

      ~if not equipped, there's nothing more to do
      doneif (field[grIsEquip].value = 0)

      ~apply any general penalty required (e.g. defense penalties or the like)
      ~.... add code here ....
      ]]></eval>

    <!-- Apply effects of the equipped armor/shield -->
    <eval index="2" phase="PreTraits" priority="5000">
      <before name="Calc trtFinal"/>
      <after name="Equipped"/><![CDATA[
      ~if this gear is not equipped, skip it
      doneif (field[grIsEquip].value = 0)

      ~apply the appropriate trait adjustments for the equipment
      #traitbonus[trDefense] += field[defDefense].value
      ]]></eval>

    <!-- Assign any derived special notes to the appropriate field -->
    <eval index="3" phase="Render" priority="1000"><![CDATA[
      var special as string

      ~append any special attributes appropriately (if any)
      var attribs as string
      attribs = tagnames[ArmorSpec.?,", "]
      special = splice(special,attribs,", ")

      ~append any special details for this weapon
      special = splice(special,field[defSpecial].text,", ")

      ~we've synthesized the notes for the weapon
      field[defNotes].text = special
      ]]></eval>
    <!-- Check the strength requirement, which we only treat as a problem for things. -->
    <prereq message="Strength requirement not met.">
      <validate><![CDATA[
        ~if this is a pick, we're valid
        ~NOTE! We assume that equipping an item without the strength just applies penalties.
        validif (@ispick <> 0)

        ~verify whether we meet the strength requirement
        validif (#trait[attrStr] >= altthing.field[defStrReq].value)
        ]]></validate>
      </prereq>

    </component>


  <!-- Armor component
        Armor derives from this component. The tracking of multiple pieces of armor
        on the character is automatically managed.
  -->
  <component
    id="Armor"
    name="Armor"
    autocompset="no">
	  
    <!-- Each piece of armor needs its own identity tag to detect multiple pieces being equipped -->
    <identity group="Armor"/>

    <!-- All armor gets the same tag for sorting purposes -->
    <tag group="Armory" tag="Armor"/>

    <!-- If we're equipped and not a natural form, track the armor on the actor -->
    <eval index="1" phase="Setup" priority="5000" name="Equip Armor"><![CDATA[
      if (field[grIsEquip].value > 0) then
        if (tagis[Equipment.Natural] = 0) then
          perform forward[Armor.?]
          endif
        endif
      ]]></eval>

    <!-- Apply effects of the equipped armor -->
    <eval index="2" phase="PreTraits" priority="5000" name="Apply Armor">
      <before name="Calc trtFinal"/>
      <after name="Equipped"/><![CDATA[
      ~if this gear is not equipped, skip it
      doneif (field[grIsEquip].value = 0)

      ~ apply the appropriate trait adjustments for the equipment
      ~ only use the highest available stackable value in case more than one is equipped
      var defense as number
      defense = field[defDefense].value
      if (tagis[ArmorLoc.Torso] <> 0) then
        if (tagis[Equipment.StackArmor] = 0) then
          if (defense > herofield[acDefTorso].value) then
            herofield[acDefTorso].value = defense
            endif
		else
		  herofield[acDefTorso].value += defense
          endif
        endif
      if (tagis[ArmorLoc.Head] <> 0) then
        if (tagis[Equipment.StackArmor] = 0) then
          if (defense > herofield[acDefHead].value) then
            herofield[acDefHead].value = defense
            endif
		else
		  herofield[acDefHead].value += defense
          endif
        endif
      if (tagis[ArmorLoc.Arms] <> 0) then
        if (tagis[Equipment.StackArmor] = 0) then
          if (defense > herofield[acDefArms].value) then
            herofield[acDefArms].value = defense
            endif
		else
		  herofield[acDefArms].value += defense
          endif
        endif
      if (tagis[ArmorLoc.Legs] <> 0) then
        if (tagis[Equipment.StackArmor] = 0) then
          if (defense > herofield[acDefLegs].value) then
            herofield[acDefLegs].value = defense
            endif
		else
		  herofield[acDefLegs].value += defense
          endif
        endif
      ]]></eval>

    </component>

  <!-- Shield component
        Shields derive from this component. The tracking of multiple shields on the
        character is automatically managed.
  -->
  <component
    id="Shield"
    name="Shield"
    autocompset="no">

    <!-- Each shield needs its own identity tag to detect multiple shields being equipped -->
    <identity group="Shield"/>

    <!-- All shields get the same tag for sorting purposes -->
    <tag group="Armory" tag="Shield"/>

    <!-- Shield require one hand by default -->
    <tag group="Equipment" tag="Hand"/>

    <!-- If we're equipped, track the shield on the actor -->
    <eval index="1" phase="Setup" priority="5000" name="Equip Shield"><![CDATA[
      if (field[grIsEquip].value > 0) then
        perform forward[Shield.?]
        endif
      ]]></eval>

    <!-- If multiple shields are equipped, mark ourselves invalid but don't
        flag a separate validation error for each piece -->
    <evalrule index="1" phase="Validate" priority="10000" message="?" issilent="yes"><![CDATA[
      ~if this gear is not equipped, we're valid
      validif (field[grIsEquip].value = 0)

      ~if there are NOT multiple shields equipped, we're valid
      validif (hero.tagcount[Shield.?] <= 1)

      ~mark the tab as invalid
      linkvalid = 0
      ]]></evalrule>

    </component>


  <!-- Ammunition component
        Bullets and the like derive from this component. Ammunition blends gear with
        a tracker that lets the user monitor the consumption of the ammunition.
  -->
  <component
    id="Ammunition"
    name="Ammunition"
    autocompset="no">
	
    <!-- Damage rating of the ammunition -->
    <field
      id="amDamage"
      name="Damage"
      type="derived"
      maxlength="20">
      </field>
    <field
      id="amCrit"
      name="Critical"
      type="derived"
      maxlength="20">
    </field>
        <field
      id="amArmorRating"
      name="Armor Rating"
      type="derived"
      maxlength="20">
    </field>
  

    <field
      id="amBlast"
      name="Blast Rating"
      type="derived"
	  maxlength="15"
	  maxfinal="15">
	  <finalize><![CDATA[
        @text = tagnames[BlastRating.?,","]
        ]]></finalize>
      </field>
	  <identity group="AmmoType"/>
    <!-- Initialize the user value to the new quantity -->
    <creation><![CDATA[
      ~if we don't have a transaction pick to initialize from, use what we know;
      ~this can occur if the gear is bootstrapped or auto-added for the actor
      if (hero.istransact = 0) then
        field[trkUser].value = field[stackQty].value * field[lotsize].value

      ~otherwise, use the contents of the transaction pick to start our value
      else
        field[trkUser].value = hero.transact.field[xactQty].value
        endif
      ]]></creation>

    <!-- Call the appropriate procedures to perform transaction setup, buy, and sell behaviors -->
    <xactsetup><![CDATA[
	  	
      ~perform standard transaction setup for the gear
      call XactSetup

      ~initialize any transaction fields appropriately from this piece of gear
      ~.... add code here ....
      ]]></xactsetup>

    <xactbuy><![CDATA[
      call XactBuy
      ]]></xactbuy>

    <xactsell><![CDATA[
      call XactSell
      ]]></xactsell>
	
    <!-- The tracker quantity should reset to the maximum value -->
    <tag group="Helper" tag="ResetMax"/>
	
    <!-- Setup our tracker bounds based on the quantity purchased -->
    <eval index="1" phase="Final" priority="1000"><![CDATA[
      field[trkMin].value = 0
      field[trkMax].value = field[stackQty].value
      ]]></eval>

    <eval index="2" phase="Final" priority="10000"><![CDATA[
	  ~make sure we're in a gizmo to travel to
	  doneif (isgizmo = 0)
	  
	  if (isgizmo = 0) then
	    if (field[grIsEquip].value <> 0) then
		    if (empty(field[amDamage].text) = 0) then
	          parent.field[wpDamage].text = field[amDamage].text
			  endif
        if (empty(field[amCrit].text) = 0) then
	        parent.field[wpCrit].text = field[amCrit].text
			  endif
        if (empty(field[amArmorRating].text) = 0) then
	        parent.field[wpArmorRating].text = field[amArmorRating].text
			  endif
        if (empty(field[amBlast].text) = 0) then
	        parent.field[wpBlast].text = field[amBlast].text
			  endif
		  endif
		endif

	  ~make sure we're in a gizmo to travel to
	  doneif (parent.isgizmo = 0)
	  
	  var parCost as number
	  var myCost as number
		  
	  parCost = parent.field[grCost].value
	  myCost = parCost * parent.field[wpReloadCost].value

	  field[grCost].value = myCost
	  parent.field[grTotalCost].value += myCost * field[stackQty].value
      ]]></eval>

    <!-- Add the quantities from the other pick into this one -->
    <merge><![CDATA[
      field[trkMax].value += altpick.field[trkMax].value
      field[trkUser].value += altpick.field[trkUser].value
      ]]></merge>

    <!-- Split the quantities properly across the two picks -->
    <split><![CDATA[
      ~save the quantity of ammo that still remains unused
      var user as number
      user = field[trkUser].value

      ~update the new "max" values for both picks based on the stack quantity
      field[trkMax].value = field[stackQty].value
      altpick.field[trkMax].value -= altpick.field[stackQty].value

      ~the user value for the first pick is the quantity of ammo still unused,
      ~subject to the maximum size for the pick
      field[trkUser].value = minimum(user,field[trkMax].value)

      ~subtract the quantity allocated to the first pick from what's now left
      user -= field[trkUser].value

      ~if we have any unused ammo left to assign to the other pick, assign it
      if (user <= 0) then
        altpick.field[trkUser].value = 0
      else
        altpick.field[trkUser].value = user
        endif
      ]]></split>

    </component>

  <!-- AmmoHelp component
        Each AmmoHelp Gizmo derives from this component
  -->
  
  <component
    id="AmmoHelp"
    name="Ammo Helper">
	
    <!-- Gear cost -->
    <field
      id="AmmoBaseCost"
      name="Base Cost"
      minvalue="0"
      defvalue="0"
      type="derived">
	  </field>
	
    <!-- Gear cost -->
    <field
      id="AmmoReloadCost"
      name="Reload Cost"
      minvalue="0"
      defvalue="0"
      type="derived">
	  </field>
	  
    <!-- Selection Tag Expressions -->
    <field
      id="AmmoExpr"
      name="Equipment Tag Expression"
      type="derived"
      maxlength="500">
      </field>
	
    </component>

  <!-- Define various component sets associated with the components defined above.
  -->

  <!-- No compsets are auto-defined for the component -->

  <!-- Ranged - ranged weapons -->
  <compset
    id="Ranged"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeapRange"/>
    <compref component="Consumable"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    </compset>

  <!-- Melee - melee weapons -->
  <compset
    id="Melee"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="WeapMelee"/>
    <compref component="Consumable"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    </compset>

  <!-- Weapon - all weapons (above) must include these fields -->
  <compset
    id="Weapon"
    stackable="yes">
    <compref component="WeaponBase"/>
    <compref component="Consumable"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    </compset>

  <!-- Armor -->
  <compset
    id="Armor"
    stackable="yes">
    <compref component="Armor"/>
    <compref component="Defense"/>
    <compref component="Consumable"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    </compset>

  <!-- Shield -->
  <compset
    id="Shield"
    stackable="yes">
    <compref component="Shield"/>
    <compref component="Defense"/>
    <compref component="Consumable"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    </compset>

  <!-- Defense - all armor and shields (above) must include these fields -->
  <compset
    id="Defense"
    stackable="yes">
    <compref component="Defense"/>
    <compref component="Consumable"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    </compset>

  <!-- Equipment -->
  <compset
    id="Equipment"
    stackable="yes">
    <compref component="Equipment"/>
    <compref component="Equippable"/>
    <compref component="Consumable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    </compset>

  <!-- Ammunition -->
  <compset
    id="Ammunition"
    stackable="yes">
    <compref component="Equipment"/>
    <compref component="Ammunition"/>
    <compref component="Equippable"/>
    <compref component="Gear"/>
    <compref component="Custom"/>
    <compref component="Tracker"/>
    </compset>

  <!-- Vehicle -->
  <compset
    id="Vehicle"
    stackable="no">
    <compref component="Vehicle"/>
    <compref component="VehicleBase"/>
    <compref component="Equipment"/>
    <compref component="Gear"/>
    <compref component="Minion"/>
    </compset> 
  <!-- VehicleBase -->
  <compset
    id="VehicleBase"
    stackable="no">
    <compref component="VehicleBase"/>
    <compref component="Minion"/>
    </compset>	
  <!-- Vehicle -->
  <compset
    id="VehicleAlt"
    stackable="no">
    <compref component="Vehicle"/>
    <compref component="Gear"/>
    </compset>
	
  <!-- Define any entities associated with the components defined above. -->
  <!-- Ammunition Load -->
  <!-- form="ammogiz"> -->
  <entity
    id="Ammo"
    form="ammogiz">
    <bootstrap thing="AmmoHelper"/>
    </entity>
	
  </document>
